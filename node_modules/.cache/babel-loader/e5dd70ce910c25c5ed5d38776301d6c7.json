{"ast":null,"code":"var _jsxFileName = \"/home/codecrunch/Documents/react/context-api/src/Memo.js\";\nimport React, { useState, useMemo, useCallback } from \"react\";\n\nconst Memo = () => {\n  // We create two states that will keep count of the number of time all hooks are called\n  const [callbackCount, setCallbackCount] = useState(0);\n  const [memoCount, setMemoCount] = useState(0);\n\n  const memoFunction = () => {\n    console.log(memoCount, \"memo called\"); // Do something that will take a lot of processing ...\n  }; // Here if we give an empty array of dependencies, the callback function will return the old value of callbackCount\n  // because useCallback will return its memoized version\n\n\n  const callbackFunction = useCallback(() => {\n    console.log(callbackCount, \"callback called\"); // Do something with callbackCount ...\n\n    return callbackCount;\n  }, [callbackCount]); // We create the memo hook, when memoCount changes, the function will be executed again\n\n  useMemo(memoFunction, [memoCount]);\n  return React.createElement(React.Fragment, null, React.createElement(ChildComponent, {\n    action: callbackFunction,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 27\n    },\n    __self: this\n  }), React.createElement(\"button\", {\n    onClick: () => setCallbackCount(callbackCount + 1),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 30\n    },\n    __self: this\n  }, \"Change callback count\"), React.createElement(\"button\", {\n    onClick: () => setMemoCount(memoCount + 1),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 36\n    },\n    __self: this\n  }, \"Change memo count\"));\n};\n\nconst ChildComponent = ({\n  action\n}) => {\n  const [value, setValue] = useState(0);\n  useEffect(() => {\n    let val = action();\n    setValue(val);\n  }, [action]);\n  return React.createElement(React.Fragment, null, \"Child : \", value);\n};\n\nexport default Memo;","map":{"version":3,"sources":["/home/codecrunch/Documents/react/context-api/src/Memo.js"],"names":["React","useState","useMemo","useCallback","Memo","callbackCount","setCallbackCount","memoCount","setMemoCount","memoFunction","console","log","callbackFunction","ChildComponent","action","value","setValue","useEffect","val"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,OAA1B,EAAmCC,WAAnC,QAAsD,OAAtD;;AAEA,MAAMC,IAAI,GAAG,MAAM;AACjB;AACA,QAAM,CAACC,aAAD,EAAgBC,gBAAhB,IAAoCL,QAAQ,CAAC,CAAD,CAAlD;AACA,QAAM,CAACM,SAAD,EAAYC,YAAZ,IAA4BP,QAAQ,CAAC,CAAD,CAA1C;;AAEA,QAAMQ,YAAY,GAAG,MAAM;AACzBC,IAAAA,OAAO,CAACC,GAAR,CAAYJ,SAAZ,EAAuB,aAAvB,EADyB,CAEzB;AACD,GAHD,CALiB,CAUjB;AACA;;;AACA,QAAMK,gBAAgB,GAAGT,WAAW,CAAC,MAAM;AACzCO,IAAAA,OAAO,CAACC,GAAR,CAAYN,aAAZ,EAA2B,iBAA3B,EADyC,CAEzC;;AACA,WAAOA,aAAP;AACD,GAJmC,EAIjC,CAACA,aAAD,CAJiC,CAApC,CAZiB,CAkBjB;;AACAH,EAAAA,OAAO,CAACO,YAAD,EAAe,CAACF,SAAD,CAAf,CAAP;AAEA,SACE,0CAEE,oBAAC,cAAD;AAAgB,IAAA,MAAM,EAAEK,gBAAxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAFF,EAKE;AAAQ,IAAA,OAAO,EAAE,MAAMN,gBAAgB,CAACD,aAAa,GAAG,CAAjB,CAAvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BALF,EAWE;AAAQ,IAAA,OAAO,EAAE,MAAMG,YAAY,CAACD,SAAS,GAAG,CAAb,CAAnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAXF,CADF;AAiBD,CAtCD;;AAwCA,MAAMM,cAAc,GAAG,CAAC;AAAEC,EAAAA;AAAF,CAAD,KAAgB;AACrC,QAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBf,QAAQ,CAAC,CAAD,CAAlC;AAEAgB,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIC,GAAG,GAAGJ,MAAM,EAAhB;AACAE,IAAAA,QAAQ,CAACE,GAAD,CAAR;AACD,GAHQ,EAGN,CAACJ,MAAD,CAHM,CAAT;AAKA,SACE,sDACWC,KADX,CADF;AAKD,CAbD;;AAeA,eAAeX,IAAf","sourcesContent":["import React, { useState, useMemo, useCallback } from \"react\";\n\nconst Memo = () => {\n  // We create two states that will keep count of the number of time all hooks are called\n  const [callbackCount, setCallbackCount] = useState(0);\n  const [memoCount, setMemoCount] = useState(0);\n\n  const memoFunction = () => {\n    console.log(memoCount, \"memo called\");\n    // Do something that will take a lot of processing ...\n  };\n\n  // Here if we give an empty array of dependencies, the callback function will return the old value of callbackCount\n  // because useCallback will return its memoized version\n  const callbackFunction = useCallback(() => {\n    console.log(callbackCount, \"callback called\");\n    // Do something with callbackCount ...\n    return callbackCount;\n  }, [callbackCount]);\n\n  // We create the memo hook, when memoCount changes, the function will be executed again\n  useMemo(memoFunction, [memoCount]);\n\n  return (\n    <>\n      {/* This component will receive a function that will change when the dependency value changes */}\n      <ChildComponent action={callbackFunction} />\n\n      {/* Change the callback hook dependency to trigger a change in the child */}\n      <button onClick={() => setCallbackCount(callbackCount + 1)}>\n        Change callback count\n      </button>\n\n      {/* After creating useMemo, each change of memoCount will trigger the function passed to the hook,\n    otherwise the memoized value will be returned */}\n      <button onClick={() => setMemoCount(memoCount + 1)}>\n        Change memo count\n      </button>\n    </>\n  );\n};\n\nconst ChildComponent = ({ action }) => {\n  const [value, setValue] = useState(0)\n\n  useEffect(() => {\n    let val = action()\n    setValue(val)\n  }, [action])\n\n  return (\n    <>\n      Child : {value}\n    </>\n  )\n}\n\nexport default Memo;"]},"metadata":{},"sourceType":"module"}